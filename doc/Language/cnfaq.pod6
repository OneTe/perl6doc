=begin pod :tag<index>

=TITLE FAQ

=SUBTITLE Perl 6最常问到的问题

=head1 一般性问题

=head2  Rakudo和Perl 6 有啥区别?


正确的说法是， L<Rakudo|http://rakudo.org/> 是perl的的实现。它是目前最完全的实现版本，目前还存在其他几个实现，将来也许
会有更多的实现。Perl 6是语言的定义。目前来讲，Perl 6和Rakudo名称可以通用。

=head2 第一个perl版本是6.0.0?

NO，perl 6 第一个正式发布版是v6.c（c代笔Christmas圣诞节）。接下来发布的版本是带点版本（比如，v6.3.2）,或者大版本的话（v6.d）

我们可通过下面的命令检查Rakudo编译器是否为最新版本：

=for code :skip-test
perl6 -e 'say q[too old] if $*PERL.version before Version.new(q[6.c])'

 Rakudo Perl 6 编译器第一个发布版本是 2015.12，这个版本可以用use 6.3 指示符支持。

=head2 Perl v6.d 大概什么时候发布?


由于需要大量工作，目前还没有确切时间点

=head2 perl6开始之旅,我应该安装什么?

X<|Rakudo Star (FAQ)>

Mac用可安装Rakudo Star DMG包，下载地址：
L<http://rakudo.org/downloads/star>

Windows用户可以通过Rakudo Star MSI安装. 你必须事先安装Windows Git和Strawberry Perl5
然后用zef包管理软件安装perl6模块。

Linux用户直接下载Rakudo Star L<http://www.perl6.org/downloads/> ，然后编译安装.

Linux和Mac 用户也可以通过操作系统发行方或者第三方的二进制包安装,发行方包可能版本会老一点.

我们也提供Rakudo Star docker容器的镜像，地址为 L<https://hub.docker.com/_/rakudo-star/>

=head2 对于perl老司机我对 Rakudo的开发感兴趣，有啥好的建议？

 X<|rakudobrew (FAQ)>

你可以安装 L<rakudobrew|https://github.com/tadzik/rakudobrew> 这个工具相当于perl5的perlbrew
或者python，ruby的相应的多版本管理工具.

=head2 上哪里找Perl6的文档?

最可信的信息是perl6官方网站及其直接链接的说明，它域名为perl6.org。

L<https://perl6.org/resources/> 和
L<https://docs.perl6.org/> 是canonical官方技术引用.

现在有很多很好的在线文档，但是你需要仔细甄别其是否可用。一般通过查看页面的发布的时间，如果发布时间
太过偏远，则很有可能它已经过期了，需要忽略之。

通过以上方式你还没有找到你需要的答案的话，你还可以通过加入Freenode的 #perl6频道寻求帮助。当然你也可以
通过谷歌搜索频道信息获得类似问题及其答案。地址为：L<Google|https://www.google.com/search?q=site:irclog.perlgeek.de+inurl:perl6>.

=head2 Perl6 specification是什么?

Perl6 specification是指perl6 官方的测试套件.我们称它为roast，其地址为
L<hosted on github|https://github.com/perl6/roast>. 任何编译测试通过的就会加入到Perl 6
specification。

Roast的主分支对应最新的开发版本，它仍未划入任何的specification。其他分支则对应于不同的specific版本。
例如，"6c.errata"。

=head2 有Perl6相关主题的字汇表么?

是的, 其链接为L<glossary|/language/glossary>.

=head2 作为一个perl程序员，我想知道Perl5和Perl6的不同点是啥?

请浏览'5to6-nutshell'及其相关文档，链接为L<https://docs.perl6.org/language/5to6-nutshell>

=head2 我是一位Ruby程序，我该怎么快速入门perl6?
X<|Ruby (FAQ)>

请浏览'rb-nutshell'文档，链接为L<https://docs.perl6.org/language/rb-nutshell>

=head1 模块

=head2 Perl6有没有CPAN?
X<|CPAN (FAQ)>X<|ecosystem>

截至目前perl6还没有像CPAN一样完备的模块仓库。但是通过L<modules.perl6.org|https://modules.perl6.org/> 
有一个perl6模块的列表，叫perl6生态系统，托管在github上。通过L<zef|https://github.com/ugexe/zef/>
可以安装这些模块，在L<rakudo|http://rakudo.org/>下运行
另外,CPAN对perl6支持的工程目前也如火如荼的进行中。

=head2 我能在Perl6中使用perl模块么?
X<|Perl 5 modules (FAQ)>

没问题，通过 L<Inline::Perl5|https://github.com/niner/Inline-Perl5/>可以很好的运行大多数的perl5模块，甚至
包括Catalyst和DBI.

=head2 我能在Perl6中执行c和c++么?
X<|C and C++ (FAQ)>

L<Nativecall|https://docs.perl6.org/language/nativecall>使这工作变的非常简单.

=head2 Nativecall不能找到libfoo.so，我的系统中只有libfoo.so.1.2!

这是debian系linux运行Nativecall常见的问题.你需要安装"libfoo-dev"包，并对缺失的问题设置符号链接。

=head2 那些传统的UNIX库函数如何调用?
X<|UNIX library functions (FAQ)>
X<|POSIX (FAQ)>

利用Nativecall调用它们非常简单。同时还有一个生态系统模块L<POSIX|https://github.com/cspencer/perl6-posix>也可用.

=head2 Rakudo有核心的标准库么?

Rakudo是一个具体最小应用（测试和Nativecall等）的编译器，而不是像linux内核那样的组成

Rakudo Star是一个包含了rakudo和其他有用模块的发布版本。其他更多的库需要通过生态系统安装。 

=head2 有没有类似B::Deparse的模块？我如何处理AST?

请用C<perl6 --target=ast -e 'very-short-example()'> 去处理AST的编译单元.

=head1 语言特性

=head2 我怎么样能dump出Perl6的数据结构 (和perl5的Data::Dumper一样有类似的模块么?）
X<|Data::Dumper (FAQ)>

例如:

    my $foo="bar";
    dd $foo;          # 输出: «Str $foo = "bar"␤»
    say :$foo.perl;   # 输出: «:foo("bar")␤»
    say :$foo.gist;   # 输出: «foo => bar␤»

同时perl6生态系统也有专门的模块可以做这件事链接为：
L<Data::Dump|https://github.com/tony-o/perl6-data-dump/>, 它还可以带颜色输出结果.

=head2 Perl6命令行(REPL)下我如何得到输入命令的历史?

请安装 L<Linenoise|https://github.com/hoelzro/p6-linenoise/> 模块.

对Unix系的操作系统另外还有一个方法就是使用rlwrap.在debian系操作系统可以通过
"apt-get install rlwrap"安装。


=head2 为什么Rakudo编译这样报错?

如果 当前输出是编译时错误，否则是运行时错误。

例如:

    =begin code :skip-test
    say 1/0;   # 试图对0整除

    sub foo( Int $a, Int $b ) {...}
    foo(1)     # ===抱歉!=== 编译时报错 ...
    =end code

=head2 C<(Any)> 是啥?

L<Any|/type/Any>是默认的新建类的超类的顶级类。常常出现在定义了一个变量但是未对其赋值
的场景下，大概类似于其他语言中的undef或者null值

例如:

    my $foo;
    say $foo;         # 输出: «(Any)␤» - 注意括弧暗示了类型对象
    say $foo.^name;   # 输出: «Any␤»


(Any)不能用于检查是否被定义，在perl6中定义是一个对象的属性。通常，实例被定义，类型对象不被定义。

    say 1.defined;       # 输出: «True␤»
    say (Any).defined;   # 输出: «False␤»

=head2 C<so>是什么?

C<so>是一个弱优先级操作符，强制为L<Bool|/type/Bool>。
它和C<?> 前缀操作符具有相同语义，类似于C<and>和低优先级的C<&&>。

实例:

    say so 1|2 == 2;    # 输出: «True␤»

本例中的，比较的结果(是一个 L<Junction|/type/Junction>),被转化为布尔型打印。

=head2 C<:D> 和 C<:U> 修饰的意义?

在perl6中，类和其他类型都是对象，并且只能通过其自己类型的类型检查。

例如,如果你定义一个变量

    my Int $x = 42;

然后你不仅可以给他赋值整数（那就是，类实例Int），还有C<Int> 类型对象自己。

=for code :skip-test
$x = Int

如果你要排除类型对象，你可以附加C<:D> 类型笑脸，他带包已"定义".

    =begin code :skip-test
    my Int:D $x = 42;
    $x = Int;            # 异常退出:
                         # 给$x赋值是类型检查错误;
                         # 期待 Int:D 但是赋值的是Int
    =end code
类似的，C<:U> 限制为未定义的值，也就是说，类型对象。如果你限制既不能为类型对象
也不能为实例，你可以用C<:_>.


=head2 修饰符 C<< --> >> 有啥作用?

L«-->|/type/Signature#Constraining_Return_Types» 为限制返回为一个类型或者一个定义的值.

例子，限制为一个类型:

    =begin code :skip-test
    sub divide-to-int( Int $a, Int $b --> Int ) {
            return ($a / $b).narrow;
    }

    divide-to-int(3, 2)
    #  返回值类型检查失败期待Int但是返回Rat
    =end code

例子，限制为一个定义的返回值:

    sub discard-random-number( --> 42 ) { rand }
    say discard-random-number;
    # 输出: «42␤»

在本例中，由于返回值已经定义，所以最终值被抛弃。

=head2 我怎么从Junction抽取一个值?
X<|Junction (FAQ)>

如果你想从L<Junction|/type/Junction>中，抽取值，你可能做错了，你需要的应该是
L<Set|/type/Set>。

Junctions表示匹配的意思，不用来做操作的。如果你费用坚持这样做，你可以滥用自动线程：

    sub eigenstates(Mu $j) {
        my @states;
        -> Any $s { @states.push: $s }.($j);
        @states;
    }

    say eigenstates(1|2|3).join(', ');
    # 打印出 1, 2, 3 或者一个置换方法。

=head2 如果Str为不可改变,  C<s///> 如何工作? C<$i++> 如何工作?

perl6中，许多基本类型的值都是不可改变的，但是存放他们的变量却不是，C<s///> 操作符是对
变量的操作，操作是会生成一个新的字符串对象。同样，C<$i++>也是工作C<$i>变量上，并不是对
值本身的操作。

更多信息，可以浏览 L<containers|/language/containers>。


=head2 数组引用和自动解引用是怎么回事?需要C<@>前缀么？

在perl6中，一切皆引用，所以专门谈论引用意义不大。不像perl5，标量变量也能直接包含数组：

    my @a = 1, 2, 3;
    say @a;                 # 输出: «[1 2 3]␤»
    say @a.WHAT;            # 输出: «(Array)␤»

    my $scalar = @a;
    say $scalar;            # 输出: «[1 2 3]␤»
    say $scalar.WHAT;       # 输出: «(Array)␤»

最大的不同是插入标量中的数组当为列表上下文的一个值，而数组则会循环迭代。

    =begin code :skip-test
    my @a = 1, 2, 3;
    my $s = @a;

    for @a { ... }          # 循环3次
    for $s { ... }          # 只会循环一次

    my @flat = flat @a, @a;
    say @flat.elems;            # 输出: «6␤»

    my @nested = flat $s, $s;
    say @nested.elems;          # 输出: «2␤»
    =end code

你可以用C<@( ... )> 或者 用表达式的C<.list>方法，强制展开，或者为成员上下文（不能展开）


=head2 为什么要用sigil? 不能没有他们么?
X<|sigils (FAQ)>

有几个原因:

=item  便于解释变量为字符串

=item  给不同种类的变量和twigils隔离为微命名空间，避免命名冲突

=item  可以便捷地区分单复数

=item  就像自然语言中的强制性动名词标记，是大脑最直白处理的方式

=item  但他也不是强制的，你也可以自定义sigil（如果你介意引起歧义的话）

=head2 "Str类型不支持关联索引"

你可能是想混用字符解释器和HTML

    =begin code :skip-test
    my $foo = "abc";
    say "$foo<html-tag>";
    =end code

perl6认为C<$foo>为一个哈希，而C«<html-tag>»会被当成字符哈希键。我们用一个
大括号来加深理解：

    my $foo = "abc";
    say "{$foo}<html-tag>";

=head2 perl6中有协程么? C<yield>呢?
X<|coroutine (FAQ)>

perl6没有像python一样的C<yield>语句，但是它通过懒列表提供类似地函数式功能。
有两种普遍的方法写协程，返回懒列表


    =begin code :skip-test
    # 第一种方法, gather/take
    my @values = gather while have_data() {
        # do some computations
        take some_data();
        # do more computations
    }

    # 第二种方法, 对一个懒列表使用.map或者类似的方法
    
    my @squares = (1..*).map(-> \x { x² });
    =end code

=head2 为什么我不能从new方法初始一个私有属性，我该怎么操作?

诸如下面代码：

    class A {
        has $!x;
        method show-x {
            say $!x;
        }
    }
    A.new(x => 5).show-x;

输出不为5。私有属性是I<private>，这意味着对外不可见。如果默认构造函数可以初始化他们的话，
他们就可能暴露在公共API.

如果你坚持要这样做，可以增加一个C<submethod BUILD>来初始化他们：

    class B {
        has $!x;
        submethod BUILD(:$!x) { }
        method show-x {
            say $!x;
        }
    }
    B.new(x => 5).show-x;

C<BUILD>会被默认的构造函数调用（间接地，查看
L<Object Construction|/language/objects#Object_Construction>了解更多），构造函数调用
所有用户传递过来的命名的参数。C<:$!x> 是命名为C<x>的命名参数，当带 C<x>命名参数被调用
时，他的值会被绑定到属性 C<$!x>。

如果不这样做。如果名称是公有的，这样定义C<$.x>也是没有害处。因为默认外部视图是只读的，
你仍然只能通过内部地 C<$!x>操作它。

=head2 C<say>, C<put> 和 C<print> 有啥区别?

最明显地差异是 C<say>和 C<put>输出会自带换行符，但是C<print>没有。

其他的不同时：C<print>和C<put>通过调用C<Str>方法把所有参数项会当成一个字符串，C<say>则
是用 C<gist>方法。前者适合机器，后者更人性化。

或者完全的不同，C<$obj.Str> 给出一个字符表达，C<$obj.gist>给出一个简单对象总结，适合开发人员
辨别。 C<$obj.perl>会给出一个perl式的表达。

例如：类型对象，也叫做“未定义值”，字符化结果为一个空串，并且给予警告。而C<gist>方法会返回
类型的名称，紧跟着一个空括弧（表示除了类型外没有任何值）。 

    my Date $x;     # $x包含一个Date类型对象
    print $x;       # 输出为空和警告
    say $x;         # 输出: «(Date)␤»

所以，C<say>更适合做调试；显示是人优化过的； C<print>和C<put>更适合给其他应用输出结果。

C<put>是介于C<print>和C<say>之间的调和。和C<print>一样适合为其他程序输出结果，同时也像
C<say>一样输出结果自带换行。
and like C<say>, it adds a newline at the end of the output.

=head2 C<token>和C<rule>有何不同 ?

<regex>,C<token>和C<rule> 都用于引入正则表达式，但是语法上略有不同。

C<token>意味着C<:ratchet>或者C<:r>修饰符，这会防止规则被回溯。

C<rule> 表示C<:ratchet>和C<:sigspace>（简写为C<:s>）修饰符，意味着规则不可以回溯，并且将
正则表达式中空白符号作为 C«<.ws>» 调用(不捕获)（例如，可以用来匹配空格，除了两单词之间的空格）。
正则表达式开头和每个可选分支|的开头空白会被忽略。

C<regex> 定义一个没有任何暗示修饰符的纯正则.

=head2 C<die>和C<fail>有啥不同?

C<die>抛出一个异常.

C<fail> 返回一个C<Failure>对象.（如果在词法范围内调用定义过 C<use fatal;>），C<fail>抛出一个异常
而不是返回)。  

C<Failure>是一个非抛出或者“懒”异常。它一个包含了异常的对象，如果你想用 C<Failure>作为普通对象
抛出一个异常。或者在sink上下文中忽略它。

C<Failure>在C<defined>检查中返回C<False>，你可以用 C<exception>方法抽取异常。

=head2 为什么C<wantarray>和C<want> 不见了?  我怎么才能不同上下文中返回不同的类型?

perl5用L<C<wantarray>|/language/5to6-perlfunc#wantarray>函数来测试调用的对象是void，scalar或者列表。
perl6没有这样的结构，因为perl6的上下文不会向内流；例如，一个例程不需要知道哪个上下文被调用了，
因为上下文是懒的（只有在最后结果被使用时候才会知道）。

例如，perl6有多调度器，所以，下面的代码：

    =begin code :skip-test
    multi w(Int $x) { say 'Int' }
    multi w(Str $x) { say 'Str' }
    w(f());
    =end code

没有办法知道调用的 sub C<f>需要一个字符串或者整数，由于它自己现在也不知道会调用啥
一般来讲，这需要解决halting问题，对perl编译器作者也是个头疼的问题。

实现perl6上下文敏感的一个方法是返回一个对象。它知道如何响应上下文中典型的方法调用。
在perl6中，相比较它听起来，这实际上是一个L<lot easier|/language/5to6-perlfunc#wantarray>，
和其他语言的其他特性，既可以减轻首先需要的并且最大可能是覆盖到wantarray的用例。

例如，regex匹配返回L<匹配对象，知道如何影响列表索引，哈希索引。并且可以变成匹配字符串|/type/Match>

=head2 C<Pointer>和C<OpaquePointer>有什么不同?

C<OpaquePointer>已经过时，被C<Pointer>取代了.

=head1 Perl6实现
X<|Perl 6 Implementation (FAQ)>

=head2 What Perl 6 Implementations are available?

Currently the best developed is Rakudo (using multiple Virtual Machine
backends). Historic implementations include Niecza (.NET) and Pugs (Haskell).
Others are listed at  L<Perl 6 Compilers|https://www.perl6.org/compilers/>

=head2 What language is Rakudo written in?

A short answer is that Rakudo is written almost entirely in Perl 6. A more
detailed answer is that Rakudo is written in a mixture of Perl 6 and NQP ("Not
Quite Perl"). NQP is a lightweight Perl 6-like environment for virtual
machines; it's designed to be a high-level way to create compilers and
libraries for virtual machines (such as MoarVM and JVM) using Perl 6 syntax.

=head2 What language is NQP written in?
X<|NQP (FAQ)>

NQP is a mixture of (1) NQP code, (2) whatever language the underlying virtual
machine is using, (3) some third-party C and Java libraries, and (4) some
bootstrapping files created by earlier runs of the build process.

=head2 Is Perl 6 Lisp?

    (not (not Nil))

=head1 Meta Questions and Advocacy

=head2 Why is Perl 6 called Perl?

… As opposed to some other name that didn't imply all the things
that the higher number might indicate on other languages.

The short answer is that it was Larry's choice under
L<Rule 1|http://perldoc.perl.org/5.12.4/perlhack.html#DESCRIPTION>.

The community considers Perl 5 and Perl 6 sister languages - they have
a lot in common, address many of the same problem spaces, but Perl 6 is not
intended to replace Perl 5. In fact, both languages interoperate with
each other.

=head2 When will Perl 6 be ready? Is it ready now?

Readiness of programming languages and their compilers is not a binary
decision. As the language and the implementations evolve, they
grow steadily more usable. Depending on your needs,
Perl 6 and its compilers may or may not be ready for you.

That said, version 6.c (Christmas 2015) is the first official release of Perl 6
as a language, along with a validation suite and a compiler that passes it.

=head2 Why should I learn Perl 6? What's so great about it?

Perl 6 unifies many great ideas that aren't usually found in other programming
languages. While several other languages offer some of these features, none of
them offer all.

=item Perl 6 offers procedural, object-oriented AND functional programming methodologies.

=item Easy to use consistent syntax, using invariable sigils for data-structures.

=item Full grapheme based Unicode support, including Annex #29.

=item Clean, more readable regular expressions; taken to the next level of usability, with a lot more functionality. Named regular expressions improve ease of use.

=item Junctions allowing easy checking of multiple possibilities; e.g., $a == 1|3|42 ( is $a equal to 1 or 3 or 42).

=item Dynamic variables provide a lexically scoped alternative to global variables.

=item Emphasis on composability and lexical scoping to prevent “action at a distance”; e.g., imports are always lexically scoped.

=item Easy to understand consistent scoping rules and closures.

=item Powerful object orientation, with classes and roles (everything can be seen as an object). Inheritance. Subtyping. Code-reuse.

=item Introspection into objects and meta-objects (turtles all the way down).

=item Meta Object Protocol allowing for meta-programming without needing to generate / parse code.

=item Subroutine and method signatures for easy unpacking of positional and named parameters.

=item Multi dispatch for identically named subroutines/methods with different signatures, based on arity, types and optional additional code.

=item Compile time error reporting on unknown subroutines / impossible dispatch.

=item Optional gradual type-checking at no additional runtime cost. With optional type annotations.

=item Advanced error reporting based on introspection of the compiler/runtime state. This means more useful, more precise error messages.

=item Phasers (like BEGIN / END) allow code to be executed at scope entry / exit, loop first / last / next and many more special contexts.

=item High level concurrency model, both for implicit as well as explicit multi-processing, which goes way beyond primitive threads and locks. Perl 6's concurrency offers a rich set of (composable) tools.

=item Multiple-core computers are getting used more and more, and with Perl 6 these can be used thanks to parallelism, both implicit (e.g., with the >>. method) and explicit ( start { code } ). This is important, because Moore's Law is ending.

=item Structured language support is provided to enable programming for asynchronous execution of code.

=item Supplies allow code to be executed when something happens (like a timer, or a signal, or a file-system event).

=item react / whenever / supply keywords allows easy construction of interactive, event driven applications.

=item Lazy evaluation when possible, eager evaluation when wanted or necessary. This means, for example, lazy lists, and even infinite lazy lists, like the Fibonacci sequence, or all prime numbers.

=item Native data types for faster, closer to the metal, processing.

=item Interfacing to external libraries in C / C++ are trivially simple with NativeCall.

=item Interfacing with Perl 5 (CPAN) / Python modules trivially simple with Inline::Perl5 and Inline::Python.

=item Can have multiple versions of a module installed and loaded simultaneously.

=item System administration simplified due to simpler update/upgrade policies.

=item Simple numeric computation without precision loss because of Rats (rational numbers).

=item Extensible grammars for parsing data or code (which Perl 6 uses to parse itself).

=item Perl 6 is a very mutable language (define your own functions, operators, traits and data-types, which modify the parser for you).

=item Large selection of data-types, plus the possibility to create your own types.

=item Multi-dimensional shaped and/or native arrays with proper bounds checking.

=item Execute code at any time during parsing of a grammar, or when a certain match occurred.

=item Adding a custom operator or adding a trait is as simple as writing a subroutine.

=item Automatic generation of hyper-operators on any operator (system or custom added).

=item Runs on a variety of back-ends. Currently MoarVM & JVM, JavaScript in development, more may follow.

=item Runtime optimization of hot code paths during execution (JIT).

=item Runs on small (e.g., Raspberry Pi) and large multi-processor hardware.

=item Garbage collection based: no timely destruction, so no ref-counting necessary. Use phasers for timely actions.

=item Methods can be mixed into any instantiated object at runtime; e.g., to allow adding out-of-band data.

=item Easy command-line interface accessible by MAIN subroutine with multiple dispatch and automated usage message generation.

=item Fewer lines of code allow for more compact program creation. Huffman-coding of names allows for better readability.

=item Lazy lists defined with a simple iterator interface, which any class can supply by minimally supplying a single method.

=item Perl 6's mottos remain the same as they have been for Perl all along: “Perl is different. In a nutshell, Perl is designed to make the easy jobs easy, without making the hard jobs impossible.” and “There Is More Than One Way To Do It”. Now with even more -Ofun added.

Please see the L<feature comparison
matrix|https://perl6.org/compilers/features> for an overview of implemented
features.

=head2 Is Perl 6 fast enough for me?

That depends on what you are doing. Rakudo has been developed with the
philosophy of "make it work right then make it work fast". It's fast for some
things already but needs work for others.
Since Perl 6 provides lots of clues to the JIT that other dynamic languages don't, we think
we'll have a lot of headroom for performance improvements. Some things already
run faster than Perl 5.

Perl 5 programmers should be aware that Perl 6 comes with more built-in
functionality. Simple benchmarks will be misleading unless you include
things like Moose, type checking modules etc. in your Perl 5 script.

The following crude benchmarks, with all the usual caveats about such things,
show that Perl 6 can be faster than Perl 5 for similar tasks if
the big weaponry is included; at the same time, Perl 5 can be faster
if only the bare bones are included.

Try it on your system. You may be pleasantly surprised!

Examples:

    =begin code :skip-test
    # Perl 6 version
    use v6.c;

    class Foo { has $.i is rw };

    for 1..1_000_000 -> $i {
        my $obj = Foo.new;
        $obj.i = $i;
    }

    # Perl 5 version
    package Foo;
    use Moose;

    has i => (is => 'rw');

    __PACKAGE__->meta->make_immutable;

    for my $i (1..1_000_000) {
        my $obj = Foo->new;
        $obj->i($i);
    }

    1;

    # Another Perl 5 version that offers bare-bones set of features
    # compared to Moose/Perl 6's version but those are not needed in this
    # specific, simple program anyway.
    package Foo;
    use Mojo::Base -base;

    has 'i';

    for my $i (1..1_000_000) {
        my $obj = Foo->new;
        $obj->i($i);
    }

    1;

    # A perl program which works under both perl5 (with perl -Mbigint)
    # and perl6

    my ($prev, $current) = (1, 0);

    for (0..100_000) {
        ($prev, $current) = ($current, $prev + $current);
    }
    print $current;
    =end code

=end pod
